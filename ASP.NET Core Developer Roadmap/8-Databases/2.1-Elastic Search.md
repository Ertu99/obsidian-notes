
Bir .NET MimarÄ± olarak Elasticsearch'Ã¼ sadece "arama kutusunu hÄ±zlandÄ±ran araÃ§" olarak gÃ¶remezsin. O, aynÄ± zamanda devasa bir **Log Analiz Motoru** ve **NoSQL Veri TabanÄ±** Ã¶zelliklerine sahip, daÄŸÄ±tÄ±k (distributed) bir canavardÄ±r.

AttÄ±ÄŸÄ±n metin onun temel Ã¶zelliklerini (Distributed, Open-Source, Lucene tabanlÄ±) Ã¶zetlemiÅŸ. Ancak biz bir mÃ¼hendis olarak **Sharding (ParÃ§alama)**, **Replication (Yedekleme)** ve **ELK Stack** kavramlarÄ±nÄ± derinlemesine inceleyeceÄŸiz.

---

### 1. Mimari: Cluster, Node ve Shard (DaÄŸÄ±tÄ±k YapÄ±)

Elasticsearch'Ã¼ gÃ¼Ã§lÃ¼ kÄ±lan ÅŸey, tek bir sunucuya baÄŸÄ±mlÄ± kalmamasÄ±dÄ±r.

1. **Cluster (KÃ¼me):** Birlikte Ã§alÄ±ÅŸan sunucularÄ±n tamamÄ±na verilen isimdir.
    
2. **Node (DÃ¼ÄŸÃ¼m):** KÃ¼meyi oluÅŸturan her bir sunucudur (veya sanal makinedir).
    
3. **Index (Dizin):** SQL'deki "Database" veya "Table" kavramÄ±na benzer. DÃ¶kÃ¼manlarÄ±n (verilerin) tutulduÄŸu mantÄ±ksal alandÄ±r.
    

MÃ¼hendislik DetayÄ±: Sharding (ParÃ§alama)

Diyelim ki 1 TB boyutunda bir "Loglar" indeksin var. Ama senin disklerin 500 GB. Bu veriyi nasÄ±l saklayacaksÄ±n?

Elasticsearch, veriyi Shard adÄ± verilen parÃ§alara bÃ¶ler.

- Loglar Ä°ndeksi -> Shard A (500GB) + Shard B (500GB).
    
- Shard A'yÄ± Node-1'e, Shard B'yi Node-2'ye koyar.
    
- **SonuÃ§:** Depolama alanÄ± yatayda (Horizontal Scaling) sÄ±nÄ±rsÄ±z bÃ¼yÃ¼yebilir.
    

---

### 2. High Availability: Replicas (Yedekler)

Bir mÃ¼hendis her zaman "Ya sunucu yanarsa?" diye dÃ¼ÅŸÃ¼nÃ¼r.

Elasticsearch'te her Shard'Ä±n (Primary Shard) bir veya daha fazla kopyasÄ± (Replica Shard) olabilir.

- **Kural:** Bir Primary Shard ile onun Replica'sÄ± **asla aynÄ± Node Ã¼zerinde** durmaz.
    
- **Senaryo:** Node-1 (iÃ§inde Primary Shard A var) Ã§Ã¶ktÃ¼.
    
- **Kurtarma:** Elasticsearch hemen Node-2'deki Replica Shard A'yÄ± "Yeni Primary" ilan eder. Veri kaybÄ± olmaz, sistem Ã§alÄ±ÅŸmaya devam eder.
    

**Performans Ä°pucu:** Replica'lar sadece gÃ¼venlik iÃ§in deÄŸildir. Okuma (Search) istekleri Replica'lara daÄŸÄ±tÄ±labilir. Yani Replica sayÄ±sÄ±nÄ± artÄ±rmak, okuma hÄ±zÄ±nÄ± artÄ±rÄ±r (Read Scalability).

---

### 3. Terminoloji: SQL vs Elasticsearch

Bir Backend geliÅŸtiricisi olarak kavramlarÄ± eÅŸleÅŸtirmek iÅŸini kolaylaÅŸtÄ±rÄ±r:

|**SQL (Relational)**|**Elasticsearch (Document Store)**|**AÃ§Ä±klama**|
|---|---|---|
|Database / Table|**Index**|Verilerin toplandÄ±ÄŸÄ± mantÄ±ksal alan.|
|Row (SatÄ±r)|**Document**|Tek bir veri kaydÄ± (JSON formatÄ±nda).|
|Column (SÃ¼tun)|**Field**|JSON iÃ§indeki alanlar (Ad, Soyad).|
|Schema|**Mapping**|Hangi alanÄ±n hangi tipte (Text, Keyword, Date) olduÄŸu.|
|SELECT|**GET / Search API**|Veri Ã§ekme.|

**Dikkat:** Elasticsearch "Schema-less" (ÅemasÄ±z) olarak bilinir, yani JSON'Ä± attÄ±ÄŸÄ±nda kabul eder. Ancak **Mapping**'i (ÅemayÄ±) elle tanÄ±mlamak bir "Best Practice"tir. Aksi takdirde tarihi metin (string) olarak algÄ±layabilir ve tarih bazlÄ± arama yapamazsÄ±n.

---

### 4. ELK Stack (Ekosistem)

Elasticsearch genellikle tek baÅŸÄ±na kullanÄ±lmaz. SektÃ¶rde **ELK Stack** adÄ± verilen muhteÅŸem Ã¼Ã§lÃ¼ ile anÄ±lÄ±r:

1. **E - Elasticsearch:** Motor. Veriyi saklar ve arar.
    
2. **L - Logstash:** Boru hattÄ± (Pipeline). Veriyi Ã§eÅŸitli kaynaklardan (Sunucu loglarÄ±, SQL veritabanÄ±, CSV dosyasÄ±) toplar, iÅŸler (parse eder) ve Elasticsearch'e atar.
    
3. **K - Kibana:** ArayÃ¼z (UI). Elasticsearch iÃ§indeki veriyi grafiklere, haritalara ve dashboard'lara dÃ¶ker.
    
    - _KullanÄ±m:_ "Siteme son 1 saatte hangi Ã¼lkelerden saldÄ±rÄ± geldi?" sorusunun cevabÄ±nÄ± Kibana haritasÄ±nda izlersin.
        

_(Not: ArtÄ±k "Beats" adÄ±nda hafif veri toplayÄ±cÄ±lar da eklendiÄŸi iÃ§in bazen "Elastic Stack" denir)._

---

### 5. .NET Core Entegrasyonu (NEST)

C# ile Elasticsearch'e baÄŸlanmak iÃ§in resmi kÃ¼tÃ¼phane **NEST** (veya yeni adÄ±yla `Elastic.Clients.Elasticsearch`) kullanÄ±lÄ±r.

Elasticsearch **RESTful API** Ã¼zerinden (HTTP/JSON) haberleÅŸtiÄŸi iÃ§in aslÄ±nda `HttpClient` ile bile istek atabilirsin. Ancak NEST, bunu C# nesneleriyle (Typed) yapmanÄ± saÄŸlar.

C#

```cs
var settings = new ConnectionSettings(new Uri("http://localhost:9200"))
    .DefaultIndex("urunler"); // VarsayÄ±lan indeks

var client = new ElasticClient(settings);

// C# nesnesini indexle (Kaydet)
var urun = new Urun { Id = 1, Ad = "KÄ±rmÄ±zÄ± Mont" };
var response = await client.IndexDocumentAsync(urun);

// Arama Yap (LINQ benzeri sÃ¶zdizimi)
var searchResponse = await client.SearchAsync<Urun>(s => s
    .Query(q => q
        .Match(m => m
            .Field(f => f.Ad)
            .Query("mont")
        )
    )
);
```

---


### 2.1. Elasticsearch (Distributed Search Engine)

**ğŸ§’ 6 YaÅŸÄ±ndaki Ã‡ocuÄŸa (KÃ¼tÃ¼phane Ekibi Analojisi):** "Okul kÃ¼tÃ¼phanesinde 1 milyon tane kitap olduÄŸunu ve bir kelimeyi aradÄ±ÄŸÄ±nÄ± dÃ¼ÅŸÃ¼n. EÄŸer tek baÅŸÄ±na ararsan gÃ¼nler sÃ¼rer (Standart SQL). **Elasticsearch**, kÃ¼tÃ¼phaneye 10 tane sÃ¼per hÄ±zlÄ± arkadaÅŸÄ±nÄ± (Nodes) Ã§aÄŸÄ±rmak gibidir. Sen kitaplarÄ± 10 parÃ§aya bÃ¶lersin (Sharding) ve her arkadaÅŸÄ±na bir parÃ§a verirsin. 'Bana Elma kelimesini bulun!' diye baÄŸÄ±rdÄ±ÄŸÄ±nda, 10 arkadaÅŸÄ±n aynÄ± anda kendi parÃ§alarÄ±na bakar ve saniyesinde cevabÄ± yapÄ±ÅŸtÄ±rÄ±r. AyrÄ±ca, olur da bir arkadaÅŸÄ±n hastalanÄ±p eve giderse diye, her parÃ§anÄ±n fotokopisini Ã§ekip diÄŸer arkadaÅŸlara da verirsin (**Replication**). BÃ¶ylece biri gitse bile iÅŸ durmaz, diÄŸerleri devam eder."

**ğŸ‘¨â€ğŸ’¼ MÃ¼lakatta YÃ¶neticiye (Abstraction):** "Elasticsearch, Apache Lucene altyapÄ±sÄ± Ã¼zerine kurulmuÅŸ; daÄŸÄ±tÄ±k (Distributed), Ã¶lÃ§eklenebilir ve gerÃ§ek zamanlÄ±ya yakÄ±n (Near Real-Time) bir arama ve analiz motorudur. Klasik veritabanlarÄ±nÄ±n (SQL) yavaÅŸ kaldÄ±ÄŸÄ± **Full-Text Search** (Metin Arama) ve **Log Analizi** senaryolarÄ±nda kullanÄ±rÄ±z. Bir Mimar olarak Elasticsearch'Ã¼ konumlandÄ±rÄ±rken iki temel Ã¶zelliÄŸine gÃ¼venirim:

1. **Horizontal Scalability (Yatay Ã–lÃ§eklenme):** Veri bÃ¼yÃ¼dÃ¼kÃ§e (Big Data), veriyi **Shard**'lara bÃ¶lerek birden fazla sunucuya (Node) daÄŸÄ±tabilir ve performansÄ± koruyabiliriz.
    
2. **High Availability (YÃ¼ksek EriÅŸilebilirlik):** **Replica** mekanizmasÄ± sayesinde, bir sunucu Ã§Ã¶kse bile (Node Failure), sistem yedek parÃ§a Ã¼zerinden veri kaybÄ± yaÅŸamadan Ã§alÄ±ÅŸmaya devam eder. Genellikle **ELK Stack** (Elasticsearch, Logstash, Kibana) yapÄ±sÄ± iÃ§inde, uygulamamÄ±zÄ±n loglarÄ±nÄ± merkezi olarak toplamak ve izlemek iÃ§in kullanÄ±rÄ±z."