
MongoDB, sadece "JSON saklayan bir depo" değildir. O, arkasında çok ciddi bir mühendislik barındıran, **BSON** formatı ve **Replica Set** mimarisiyle çalışan, yüksek performanslı bir dağıtık sistemdir.

Attığın metin temel tanımları (Cross-platform, Document-oriented, BSON) yapmış. Biz bu kavramları bir **Backend Mimarı** derinliğinde inceleyelim.

---

### 1. Neden JSON Değil de BSON? (Binary JSON)

Metinde MongoDB'nin **BSON (Binary JSON)** yapısını kullandığı belirtiliyor. Peki neden? JSON insan için okunabilir harika bir formattır ama makine için verimsizdir.

1. **Hız (Traversability):** JSON bir metindir (String). "Yaş" alanını bulmak için metni baştan sona taraman gerekir. BSON ise binary (ikili) formattır. Başlık bilgisinde "Yaş alanı 50. byte'ta başlıyor" bilgisi vardır. MongoDB doğrudan oraya atlar (Seek).
    
2. **Veri Tipleri:** JSON'da sadece String, Number, Boolean vardır. `Date` yoktur (String olarak tutarsın). BSON'da ise `Date`, `Int64`, `Binary Data` (Resim vb.) gibi zengin veri tipleri vardır.
    

---

### 2. Mimari Hiyerarşi

SQL Server'dan gelenler için kavramları eşleştirelim:

- **Database:** Aynı (Veritabanı).
    
- **Table -> Collection:** Tablo yerine Koleksiyon vardır. Şeması esnektir.
    
- **Row -> Document:** Satır yerine Döküman (BSON) vardır.
    
- **Column -> Field:** Sütun yerine Alan vardır.
    
- **Join -> $lookup:** Join yoktur ama `$lookup\` ile benzer işler yapılabilir (Performans maliyetlidir).
    

---

### 3. C# Entegrasyonu: `MongoDB.Driver`

.NET uygulamasında MongoDB ile konuşmak için **MongoDB.Driver** kütüphanesi kullanılır.

Kritik DI Bilgisi:

SQL Server'da DbContext (Scoped) kullanırız demiştik.

MongoDB'de ise MongoClient sınıfı Singleton olarak kaydedilmelidir.

- _Neden?_ Çünkü `MongoClient` thread-safe'tir ve arka planda bağlantı havuzunu (Connection Pool) yönetir. Her istekte `new MongoClient()` dersen havuzu tüketir ve sunucuyu kilitlersin.
    

C#

```cs
// Program.cs - Singleton Kayıt
builder.Services.AddSingleton<IMongoClient>(sp => 
    new MongoClient("mongodb://localhost:27017"));

// Kullanımı
public class ProductService {
    private readonly IMongoCollection<Product> _products;
    
    public ProductService(IMongoClient client) {
        var db = client.GetDatabase("ECommerceDb");
        _products = db.GetCollection<Product>("Products");
    }

    public async Task Create(Product p) {
        await _products.InsertOneAsync(p);
    }
}
```

---

### 4. Mühendislik Harikası: `ObjectId`

SQL'de genelde `ID` olarak `int` (Auto Increment - 1, 2, 3...) kullanırız. MongoDB'de ise varsayılan ID tipi **ObjectId**'dir (örn: `507f1f77bcf86cd799439011`).

Bu rastgele bir sayı değildir! 12 Byte'lık özel bir yapıdır:

1. **4 Byte:** Zaman Damgası (Timestamp - Saniye bazında).
    
2. **5 Byte:** Rastgele Değer (Makine ve Process ID).
    
3. **3 Byte:** Sayaç (Counter - Rastgele sayıdan başlar).
    

**Mühendislik Faydası:**

- **Client-Side Generation:** SQL'de ID'yi öğrenmek için veritabanına gitmek zorundasın (Identity). MongoDB'de ise ID'yi **C# tarafında** (istemcide) üretebilirsin. Veritabanına sormana gerek yoktur. Bu, performansı artırır.
    
- **Sıralanabilirlik:** İlk 4 byte zaman olduğu için, `ObjectId`'ler oluşturulma tarihine göre **doğal olarak sıralıdır.**
    

---

### 5. Transaction Yönetimi (ACID)

Eskiden "MongoDB'de Transaction yok" denirdi. Bu artık yanlış.

MongoDB v4.0 ile birlikte Multi-Document ACID Transactions geldi.

- Ancak dikkat: NoSQL'in doğasına aykırıdır ve performansı düşürür.
    
- **Best Practice:** Mümkünse veri modelini öyle tasarla ki (Embedding), transaction'a ihtiyacın kalmasın. Tek bir dökümanı güncellemek zaten atomiktir (Atomicity).
    

---

### 6. Ölçeklenebilirlik: Replica Set vs Sharding

MongoDB'yi Production ortamına kurarken iki kavramı bilmelisin:

1. **Replica Set (Yedeklilik):** 1 Primary (Yazan), 2 Secondary (Okuyan/Yedek) sunucu. Primary çökerse Secondary'lerden biri otomatik Primary olur. Veri kaybını önler.
    
2. **Sharding (Bölümleme):** Veriyi parçalara bölüp farklı sunuculara dağıtmak. (Bunu DynamoDB ve ElasticSearch derslerinde detaylı görmüştük).
    

---
