
**Gridify**, .NET ekosisteminde özellikle **Listeleme, Filtreleme, Sıralama ve Sayfalama (Filtering, Sorting, Pagination)** işlemlerini otomatize eden, **Expression Tree** tabanlı devrimsel bir kütüphanedir.

Genellikle API geliştirirken "Search" endpoint'leri yazarız ve bu endpoint'ler zamanla şuna döner: "Adına göre ara, yok yaşına göre ara, o da yoksa tarih aralığına bak..." Bu durum Controller'ı `if-else` cehennemine çevirir. Gridify, bu kaosu tek satıra indiren bir **Dynamic LINQ** motorudur.

Konuyu A'dan Z'ye; Mimarisi, Güvenlik Katmanı (Mapper), Performansı ve OData/GraphQL ile farkları üzerinden **tek seferde ve eksiksiz** inceliyoruz.

---

### 1. Felsefe: Neden İhtiyacımız Var? (The Boilerplate Killer)

Standart bir "Ürünleri Getir" API'sinde yazılımcı şu angaryaları yapar:

1. Parametreleri al (`string? name, int? minPrice...`).
    
2. `if (!string.IsNullOrEmpty(name))` kontrolü yap.
    
3. `query = query.Where(...)` ekle.
    
4. Sıralama için switch-case yaz (`switch(sortBy)`).
    
5. Sayfalama için `Skip` ve `Take` hesapla.
    
6. Toplam kayıt sayısını (`Count`) bulmak için veritabanına ikinci bir sorgu at.
    

**Gridify** bunların hepsini çöpe atar. İstemciden (Frontend) gelen tek bir **String** ifadeyi (`filter=name=John&page=1`) alır ve çalışma zamanında (Runtime) dinamik olarak **LINQ Expression Tree**'ye derler.

---

### 2. Nasıl Çalışır? (Syntax ve Kullanım)

Gridify, URL Query String üzerinden kendi özel dilini kullanır.

Frontend İsteği:

GET /api/users?filter=Age>20,Role=Admin&sort=Name&page=1&pageSize=10

**Backend Kodu (Tek Satır):**

C#

```cs
// Controller Action
public async Task<Paging<User>> GetUsers([FromQuery] GridifyQuery query)
{
    // Tek satırda filtrele, sırala, sayfala ve count al.
    // _dbContext.Users -> IQueryable<User>
    return await _dbContext.Users.GridifyAsync(query);
}
```

**Gridify Syntax (Operatörler):**

- **Eşittir:** `Name=Ahmet`
    
- **İçerir (Like):** `Name=*hm*` (Wildcard kullanımı)
    
- **Büyüktür/Küçüktür:** `Age>18`, `Price<=100`
    
- **Mantıksal:** `(Age>18|Role=Admin),Active=true` ("|" OR demek, "," AND demektir).
    
- **İlişkisel (Nested):** `Department.Name=IT` (Otomatik Join mantığı).
    

---

### 3. Mühendislik Detayı 1: GridifyMapper (Güvenlik Duvarı)

Gridify varsayılan olarak User sınıfındaki her alanı filtrelemeye açar.

Risk: Veritabanında PasswordHash veya IsDeleted gibi dışarı açılmaması gereken alanlar olabilir. Kötü niyetli biri filter=IsDeleted=true diyerek silinmiş verileri çekebilir.

Çözüm: GridifyMapper (Whitelist)

Bir mimar olarak asla Entity'i doğrudan Gridify'a vermemelisin. Bir Mapper konfigürasyonu yapmalısın.

C#

```cs
var mapper = new GridifyMapper<User>()
    .GenerateMappings() // Mevcut propertyleri ekle
    .RemoveMap(u => u.PasswordHash) // Şifreyi filtrelemeye kapat
    .RemoveMap(u => u.IsDeleted) // Silinenleri kapat
    .AddMap("role_name", u => u.Role.Name); // Custom isimlendirme (Alias)

// Kullanımı
var result = _context.Users.Gridify(query, mapper);
```

Bu sayede istemci `PasswordHash=...` gönderse bile Gridify hata fırlatır veya görmezden gelir. **Security by Design** sağlanır.

---

### 4. Mühendislik Detayı 2: DTO Projection (AutoMapper Entegrasyonu)

Genellikle veritabanı entity'sini (User) değil, DTO'sunu (UserDto) döneriz.

Ancak filtreleme veritabanında (User tablosunda) yapılmalı, sonuç UserDto olmalıdır.

Gridify `GridifyTo<TDto>` uzantısı ile bunu çözer:

C#

```cs
// 1. Filtrelemeyi 'User' entity'si üzerinde yapar (SQL'de çalışır).
// 2. Sonucu 'UserDto'ya çevirir (Projection).
// 3. Paging<UserDto> döner.
var result = await _context.Users.GridifyToAsync<UserDto>(query, mapper);
```

Bu işlem **Server Evaluation** yapar. Yani filtreleme RAM'de değil, SQL Server'da gerçekleşir.

---

### 5. Mühendislik Detayı 3: Expression Trees ve Performans

Gridify, Reflection (Yavaş) kullanmaz. Gelen string ifadeyi **Expression Trees** kullanarak derler (`Compile`).

- **Senaryo:** `filter=Age>20`
    
- **Gridify'ın Yaptığı:** Çalışma zamanında `p => p.Age > 20` lambda fonksiyonunu oluşturur.
    
- **EF Core:** Bu lambdayı alır ve `WHERE Age > 20` SQL sorgusuna çevirir.
    

Bu yüzden performansı, elle yazdığın LINQ sorgusuyla birebir aynıdır. Ekstra bir maliyeti (Overhead) neredeyse yoktur.

---

### 6. Alternatifler: OData ve GraphQL vs Gridify

Mülakatlarda "Neden OData kullanmadın?" diye sorarlar.

|**Özellik**|**Gridify**|**OData**|**GraphQL**|
|---|---|---|---|
|**Karmaşıklık**|Çok Düşük|Yüksek (EdmModel kurman gerekir)|Çok Yüksek (Schema, Resolver gerekir)|
|**Bağımlılık**|Yok (Hafif kütüphane)|Microsoft'a sıkı bağlı|Tamamen farklı bir mimari|
|**Response**|Sabit (DTO neyse o)|Seçilebilir (`$select`)|Tamamen Seçilebilir|
|**Kullanım**|Basit/Orta CRUD işleri|Kurumsal, ağır ERP sistemleri|Mobil/Frontend odaklı kompleks yapılar|

**Karar:** Eğer sadece "Tabloda filtreleme/sayfalama yapayım, başım ağrımasın" diyorsan **Gridify** en iyi seçimdir. OData eski ve hantaldır (XML metadata vs.). GraphQL ise basit bir admin paneli için "over-engineering" (aşırı mühendislik) olabilir.

---

### 7. İleri Seviye: Complex Filtering (Nested Collections)

Gridify'ın en güçlü yanlarından biri alt koleksiyonlarda arama yapabilmesidir.

**Senaryo:** "Siparişlerinde (Orders) toplam tutarı (Total) 1000 TL üzeri olan kullanıcıları getir."

- **Gridify String:** `Orders[Total > 1000]`
    
- **Üretilen LINQ:** `users.Where(u => u.Orders.Any(o => o.Total > 1000))`
    

Bunu elle yazmak zahmetlidir, Gridify bunu string manipülasyonu ile çözer.

---

