DynamoDB, AWS'nin "tam yÃ¶netilen" (fully-managed) NoSQL veritabanÄ±dÄ±r. Bir .NET MimarÄ± olarak bunu bilmelisin Ã§Ã¼nkÃ¼ Microservices dÃ¼nyasÄ±nda "Her servise uygun veritabanÄ±" (Polyglot Persistence) seÃ§erken, yÃ¼ksek yazma hÄ±zÄ± ve sÄ±fÄ±r bakÄ±m maliyeti gerektiren yerlerde DynamoDB bir standarttÄ±r.

Bu konuyu klasik veritabanÄ± anlatÄ±mÄ±ndan Ã§Ä±karÄ±p, **"Partitioning" (BÃ¶lÃ¼mleme)** stratejisi, **"Provisioned Throughput" (Tahsis Edilen Kapasite)** ve **"Single Table Design"** gibi ileri mÃ¼hendislik kavramlarÄ±yla inceleyelim.

---

### 1. Felsefe: Serverless & HTTP API

DynamoDB, MongoDB veya SQL Server gibi "baÄŸlantÄ± kurulan" (Connection String ile TCP aÃ§Ä±lan) bir veritabanÄ± deÄŸildir.

- **YapÄ±:** Tamamen **HTTP API** Ã¼zerinden Ã§alÄ±ÅŸÄ±r.
    
- **Sunucu:** Yoktur. (Sen gÃ¶rmezsin). "Bana 100 GB yer ver" demezsin, veri attÄ±kÃ§a bÃ¼yÃ¼r.
    
- **BakÄ±m:** Yoktur. Yedekleme, Patch geÃ§me, Sharding yapma gibi dertler AWS'nindir.
    

Bir .NET uygulamasÄ±nda SDK (`AWSSDK.DynamoDBv2`) kullanarak, her iÅŸlem iÃ§in AWS'ye bir HTTP Request atarsÄ±n.

---

### 2. Mimari: Partition Key & Sort Key (En Kritik Konu)

SQL'de Primary Key basittir (`ID`). DynamoDB'de ise Primary Key iki parÃ§adan oluÅŸabilir ve performansÄ±n kaderini bu belirler.

1. **Partition Key (PK - BÃ¶lÃ¼m AnahtarÄ±):**
    
    - Verinin fiziksel olarak hangi sunucuda (Shard) saklanacaÄŸÄ±nÄ± belirler.
        
    - DynamoDB, bu anahtarÄ± "Hash" fonksiyonundan geÃ§irir ve veriyi ilgili kutuya atar.
        
    - **MÃ¼hendislik KuralÄ±:** EÅŸit daÄŸÄ±lmalÄ±dÄ±r (High Cardinality). EÄŸer herkesin PK'sÄ± "Ä°stanbul" olursa, tÃ¼m yÃ¼k tek bir sunucuya biner (**Hot Partition** sorunu).
        
2. **Sort Key (SK - SÄ±ralama AnahtarÄ±):**
    
    - AynÄ± Partition iÃ§indeki verilerin nasÄ±l sÄ±ralanacaÄŸÄ±nÄ± belirler.
        
    - SQL'deki `one-to-many` iliÅŸkileri burada modelleriz.
        
    - _Ã–rnek:_ `PK: UserID_123`, `SK: OrderDate_2023`. Bu sayede "User 123'Ã¼n 2023'teki sipariÅŸlerini getir" sorgusu Ã§ok hÄ±zlÄ± Ã§alÄ±ÅŸÄ±r.
        

---

### 3. Okuma ve Yazma Kapasitesi (RCU & WCU)

Geleneksel veritabanlarÄ±nda "CPU/RAM" satÄ±n alÄ±rsÄ±n. DynamoDB'de ise **Throughput (Ä°ÅŸlem Hacmi)** satÄ±n alÄ±rsÄ±n.

1. **Provisioned Mode (Rezerve):**
    
    - "Benim uygulamam saniyede 50 okuma (RCU), 10 yazma (WCU) yapacak" diye baÅŸtan taahhÃ¼t verirsin.
        
    - Trafik bu sÄ±nÄ±rÄ± geÃ§erse DynamoDB "400 ThrottlingException" hatasÄ± dÃ¶ner ve isteÄŸi reddeder. (Auto-Scaling ile Ã§Ã¶zÃ¼lÃ¼r).
        
2. **On-Demand Mode (KullandÄ±kÃ§a Ã–de):**
    
    - Limit belirtmezsin. Trafik ne gelirse AWS o kadar kaynak ayÄ±rÄ±r.
        
    - Ani trafik sÄ±Ã§ramalarÄ± (Spike) olan dÃ¼zensiz uygulamalar iÃ§in idealdir ama birim maliyeti daha yÃ¼ksektir.
        

---

### 4. TutarlÄ±lÄ±k Modelleri (Consistency)

DynamoDB, **CAP Teoremi**'ne gÃ¶re **AP (Availability & Partition Tolerance)** sistemidir. Yani "Her zaman cevap veririm ama veri en gÃ¼ncel olmayabilir" der.

Bir okuma (Read) isteÄŸi yaptÄ±ÄŸÄ±nda iki seÃ§eneÄŸin vardÄ±r:

1. **Eventual Consistency (VarsayÄ±lan - Ucuz):**
    
    - Veriyi yazdÄ±n, milisaniyeler sonra okuduÄŸunda eski veriyi gÃ¶rebilirsin (Ã§Ã¼nkÃ¼ replikasyon sÃ¼rÃ¼yor olabilir).
        
    - Maliyeti: 0.5 RCU.
        
2. **Strong Consistency (GÃ¼Ã§lÃ¼ - PahalÄ±):**
    
    - Veriyi yazdÄ±ÄŸÄ±n an okursan kesinlikle en gÃ¼ncelini gÃ¶rÃ¼rsÃ¼n.
        
    - Maliyeti: 1.0 RCU (Ä°ki katÄ± para Ã¶dersin).
        

---

### 5. Secondary Indexes (Esneklik)

NoSQL'de "Join" yoktur. Veriyi farklÄ± ÅŸekillerde sorgulamak iÃ§in indeksler kullanÄ±lÄ±r.

- **LSI (Local Secondary Index):** Tabloyu yaratÄ±rken oluÅŸturulur. Partition Key aynÄ± kalÄ±r, Sort Key deÄŸiÅŸir.
    
- **GSI (Global Secondary Index):** Tablonun **kopyasÄ±nÄ±** (gÃ¶lgesini) oluÅŸturur. PK ve SK tamamen farklÄ± olabilir.
    
    - _Ã–rnek:_ Ana tabloda `UserID` ile arama yapÄ±yorsun ama bazen `Email` ile de araman gerekiyor. `Email` Ã¼zerine bir GSI kurarsÄ±n. AWS arka planda veriyi GSI tablosuna da kopyalar (Asenkron).
        

---

### 6. Paradigma DeÄŸiÅŸimi: Single Table Design

SQL'de veriyi normalize edip (MÃ¼ÅŸteriler, SipariÅŸler, ÃœrÃ¼nler) tablolara bÃ¶leriz. DynamoDB'de ise **tÃ¼m veriyi TEK BÄ°R tabloya** koymak (Single Table Design) "Best Practice" kabul edilir (Rick Houlihan ekolÃ¼).

- Tablo AdÄ±: `AppTable`
    
- `PK`: `USER#123`
    
- `SK`: `METADATA` (KullanÄ±cÄ± bilgileri burada)
    
- `PK`: `USER#123`
    
- `SK`: `ORDER#999` (SipariÅŸ bilgisi burada)
    

Tek bir sorguyla (`Query PK=USER#123`) hem kullanÄ±cÄ±yÄ± hem sipariÅŸlerini Ã§ekebilirsin (Pre-Joined Data). Bu, SQL kafasÄ±ndan Ã§Ä±kÄ±p NoSQL mÃ¼hendisliÄŸine geÃ§iÅŸin zirvesidir.

**ğŸ§’ 6 YaÅŸÄ±ndaki Ã‡ocuÄŸa (Devasa KÃ¼tÃ¼phane ve Robotlar Analojisi):** "Evdeki kitaplÄ±ÄŸÄ±n dolduÄŸunda yeni bir raf alman gerekir. Ama **DynamoDB**, Amazon'un sahibi olduÄŸu, ucu bucaÄŸÄ± gÃ¶rÃ¼nmeyen devasa bir kÃ¼tÃ¼phanedir. Sen oraya gidip 'Bana bir raf ver' demezsin. Sadece elindeki kitabÄ± bir pencereden iÃ§eri atarsÄ±n. Ama atarken Ã¼zerine bir etiket (**Partition Key**) yapÄ±ÅŸtÄ±rman ÅŸarttÄ±r. EÄŸer etikete 'Macera' yazarsan, iÃ§erideki robot o kitabÄ± alÄ±r ve 'Macera OdasÄ±'na gÃ¶tÃ¼rÃ¼r. EÄŸer etikete 'Tarih' yazarsan, 'Tarih OdasÄ±'na gÃ¶tÃ¼rÃ¼r. Burada dikkat etmen gereken bir kural var: EÄŸer okuldaki herkes aynÄ± anda kitap getirip hepsine 'Macera' yazarsa, Macera OdasÄ±'ndaki robot yorulur ve Ã§alÄ±ÅŸmayÄ± durdurur (**Hot Partition / Throttling**). DiÄŸer odalardaki robotlar ise boÅŸ boÅŸ oturur. O yÃ¼zden etiketleri Ã¶yle bir yazmalÄ±sÄ±n ki, iÅŸler robotlara eÅŸit daÄŸÄ±lsÄ±n."

**ğŸ‘¨â€ğŸ’¼ MÃ¼lakatta YÃ¶neticiye (Abstraction - Teorik Uzman Dili):** "DynamoDB, AWS'in sunduÄŸu tam yÃ¶netilen (Fully-Managed), sunucusuz (Serverless) bir NoSQL Ã§Ã¶zÃ¼mÃ¼dÃ¼r. Mimari kararlarda DynamoDB'yi, Ã¶zellikle **yÃ¼ksek Ã¶lÃ§eklenebilirlik** ve **dÃ¼ÅŸÃ¼k bakÄ±m maliyeti (NoOps)** gerektiren mikroservislerde standart olarak deÄŸerlendiririz. Geleneksel iliÅŸkisel veritabanlarÄ±ndan farklÄ± olarak burada veri modelleme stratejisi tamamen **EriÅŸim Desenlerine (Access Patterns)** gÃ¶re belirlenir:

- **Single Table Design:** SQL'deki gibi veriyi tablolara bÃ¶lÃ¼p JOIN ile birleÅŸtirmek yerine; veriyi, sorgulama ihtiyacÄ±mÄ±za gÃ¶re Ã¶nceden birleÅŸtirilmiÅŸ (Pre-joined) ÅŸekilde tek bir tabloda tutarak, milisaniyeler mertebesinde sabit performans (O(1)) hedefleriz.
    
- **Partitioning Stratejisi:** Sistemin performansÄ±nÄ± belirleyen en kritik faktÃ¶r **Partition Key** seÃ§imidir. YÃ¼kÃ¼n tek bir 'Shard' Ã¼zerine binmesini (Hot Partition) engellemek iÃ§in, anahtarÄ±n yÃ¼ksek kardinaliteye (High Cardinality) sahip olmasÄ± hayati Ã¶nem taÅŸÄ±r.
    
- **Consistency vs Cost:** CAP teoremine gÃ¶re, uygulamanÄ±n ihtiyacÄ±na baÄŸlÄ± olarak 'Eventual Consistency' ile maliyeti dÃ¼ÅŸÃ¼rebilir veya kritik iÅŸlemlerde 'Strong Consistency' ile veri tutarlÄ±lÄ±ÄŸÄ±nÄ± garanti altÄ±na alabiliriz."