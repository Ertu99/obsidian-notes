DynamoDB, AWS'nin "tam yönetilen" (fully-managed) NoSQL veritabanıdır. Bir .NET Mimarı olarak bunu bilmelisin çünkü Microservices dünyasında "Her servise uygun veritabanı" (Polyglot Persistence) seçerken, yüksek yazma hızı ve sıfır bakım maliyeti gerektiren yerlerde DynamoDB bir standarttır.

Bu konuyu klasik veritabanı anlatımından çıkarıp, **"Partitioning" (Bölümleme)** stratejisi, **"Provisioned Throughput" (Tahsis Edilen Kapasite)** ve **"Single Table Design"** gibi ileri mühendislik kavramlarıyla inceleyelim.

---

### 1. Felsefe: Serverless & HTTP API

DynamoDB, MongoDB veya SQL Server gibi "bağlantı kurulan" (Connection String ile TCP açılan) bir veritabanı değildir.

- **Yapı:** Tamamen **HTTP API** üzerinden çalışır.
    
- **Sunucu:** Yoktur. (Sen görmezsin). "Bana 100 GB yer ver" demezsin, veri attıkça büyür.
    
- **Bakım:** Yoktur. Yedekleme, Patch geçme, Sharding yapma gibi dertler AWS'nindir.
    

Bir .NET uygulamasında SDK (`AWSSDK.DynamoDBv2`) kullanarak, her işlem için AWS'ye bir HTTP Request atarsın.

---

### 2. Mimari: Partition Key & Sort Key (En Kritik Konu)

SQL'de Primary Key basittir (`ID`). DynamoDB'de ise Primary Key iki parçadan oluşabilir ve performansın kaderini bu belirler.

1. **Partition Key (PK - Bölüm Anahtarı):**
    
    - Verinin fiziksel olarak hangi sunucuda (Shard) saklanacağını belirler.
        
    - DynamoDB, bu anahtarı "Hash" fonksiyonundan geçirir ve veriyi ilgili kutuya atar.
        
    - **Mühendislik Kuralı:** Eşit dağılmalıdır (High Cardinality). Eğer herkesin PK'sı "İstanbul" olursa, tüm yük tek bir sunucuya biner (**Hot Partition** sorunu).
        
2. **Sort Key (SK - Sıralama Anahtarı):**
    
    - Aynı Partition içindeki verilerin nasıl sıralanacağını belirler.
        
    - SQL'deki `one-to-many` ilişkileri burada modelleriz.
        
    - _Örnek:_ `PK: UserID_123`, `SK: OrderDate_2023`. Bu sayede "User 123'ün 2023'teki siparişlerini getir" sorgusu çok hızlı çalışır.
        

---

### 3. Okuma ve Yazma Kapasitesi (RCU & WCU)

Geleneksel veritabanlarında "CPU/RAM" satın alırsın. DynamoDB'de ise **Throughput (İşlem Hacmi)** satın alırsın.

1. **Provisioned Mode (Rezerve):**
    
    - "Benim uygulamam saniyede 50 okuma (RCU), 10 yazma (WCU) yapacak" diye baştan taahhüt verirsin.
        
    - Trafik bu sınırı geçerse DynamoDB "400 ThrottlingException" hatası döner ve isteği reddeder. (Auto-Scaling ile çözülür).
        
2. **On-Demand Mode (Kullandıkça Öde):**
    
    - Limit belirtmezsin. Trafik ne gelirse AWS o kadar kaynak ayırır.
        
    - Ani trafik sıçramaları (Spike) olan düzensiz uygulamalar için idealdir ama birim maliyeti daha yüksektir.
        

---

### 4. Tutarlılık Modelleri (Consistency)

DynamoDB, **CAP Teoremi**'ne göre **AP (Availability & Partition Tolerance)** sistemidir. Yani "Her zaman cevap veririm ama veri en güncel olmayabilir" der.

Bir okuma (Read) isteği yaptığında iki seçeneğin vardır:

1. **Eventual Consistency (Varsayılan - Ucuz):**
    
    - Veriyi yazdın, milisaniyeler sonra okuduğunda eski veriyi görebilirsin (çünkü replikasyon sürüyor olabilir).
        
    - Maliyeti: 0.5 RCU.
        
2. **Strong Consistency (Güçlü - Pahalı):**
    
    - Veriyi yazdığın an okursan kesinlikle en güncelini görürsün.
        
    - Maliyeti: 1.0 RCU (İki katı para ödersin).
        

---

### 5. Secondary Indexes (Esneklik)

NoSQL'de "Join" yoktur. Veriyi farklı şekillerde sorgulamak için indeksler kullanılır.

- **LSI (Local Secondary Index):** Tabloyu yaratırken oluşturulur. Partition Key aynı kalır, Sort Key değişir.
    
- **GSI (Global Secondary Index):** Tablonun **kopyasını** (gölgesini) oluşturur. PK ve SK tamamen farklı olabilir.
    
    - _Örnek:_ Ana tabloda `UserID` ile arama yapıyorsun ama bazen `Email` ile de araman gerekiyor. `Email` üzerine bir GSI kurarsın. AWS arka planda veriyi GSI tablosuna da kopyalar (Asenkron).
        

---

### 6. Paradigma Değişimi: Single Table Design

SQL'de veriyi normalize edip (Müşteriler, Siparişler, Ürünler) tablolara böleriz. DynamoDB'de ise **tüm veriyi TEK BİR tabloya** koymak (Single Table Design) "Best Practice" kabul edilir (Rick Houlihan ekolü).

- Tablo Adı: `AppTable`
    
- `PK`: `USER#123`
    
- `SK`: `METADATA` (Kullanıcı bilgileri burada)
    
- `PK`: `USER#123`
    
- `SK`: `ORDER#999` (Sipariş bilgisi burada)
    

Tek bir sorguyla (`Query PK=USER#123`) hem kullanıcıyı hem siparişlerini çekebilirsin (Pre-Joined Data). Bu, SQL kafasından çıkıp NoSQL mühendisliğine geçişin zirvesidir.