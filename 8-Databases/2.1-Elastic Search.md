
Bir .NET Mimarı olarak Elasticsearch'ü sadece "arama kutusunu hızlandıran araç" olarak göremezsin. O, aynı zamanda devasa bir **Log Analiz Motoru** ve **NoSQL Veri Tabanı** özelliklerine sahip, dağıtık (distributed) bir canavardır.

Attığın metin onun temel özelliklerini (Distributed, Open-Source, Lucene tabanlı) özetlemiş. Ancak biz bir mühendis olarak **Sharding (Parçalama)**, **Replication (Yedekleme)** ve **ELK Stack** kavramlarını derinlemesine inceleyeceğiz.

---

### 1. Mimari: Cluster, Node ve Shard (Dağıtık Yapı)

Elasticsearch'ü güçlü kılan şey, tek bir sunucuya bağımlı kalmamasıdır.

1. **Cluster (Küme):** Birlikte çalışan sunucuların tamamına verilen isimdir.
    
2. **Node (Düğüm):** Kümeyi oluşturan her bir sunucudur (veya sanal makinedir).
    
3. **Index (Dizin):** SQL'deki "Database" veya "Table" kavramına benzer. Dökümanların (verilerin) tutulduğu mantıksal alandır.
    

Mühendislik Detayı: Sharding (Parçalama)

Diyelim ki 1 TB boyutunda bir "Loglar" indeksin var. Ama senin disklerin 500 GB. Bu veriyi nasıl saklayacaksın?

Elasticsearch, veriyi Shard adı verilen parçalara böler.

- Loglar İndeksi -> Shard A (500GB) + Shard B (500GB).
    
- Shard A'yı Node-1'e, Shard B'yi Node-2'ye koyar.
    
- **Sonuç:** Depolama alanı yatayda (Horizontal Scaling) sınırsız büyüyebilir.
    

---

### 2. High Availability: Replicas (Yedekler)

Bir mühendis her zaman "Ya sunucu yanarsa?" diye düşünür.

Elasticsearch'te her Shard'ın (Primary Shard) bir veya daha fazla kopyası (Replica Shard) olabilir.

- **Kural:** Bir Primary Shard ile onun Replica'sı **asla aynı Node üzerinde** durmaz.
    
- **Senaryo:** Node-1 (içinde Primary Shard A var) çöktü.
    
- **Kurtarma:** Elasticsearch hemen Node-2'deki Replica Shard A'yı "Yeni Primary" ilan eder. Veri kaybı olmaz, sistem çalışmaya devam eder.
    

**Performans İpucu:** Replica'lar sadece güvenlik için değildir. Okuma (Search) istekleri Replica'lara dağıtılabilir. Yani Replica sayısını artırmak, okuma hızını artırır (Read Scalability).

---

### 3. Terminoloji: SQL vs Elasticsearch

Bir Backend geliştiricisi olarak kavramları eşleştirmek işini kolaylaştırır:

|**SQL (Relational)**|**Elasticsearch (Document Store)**|**Açıklama**|
|---|---|---|
|Database / Table|**Index**|Verilerin toplandığı mantıksal alan.|
|Row (Satır)|**Document**|Tek bir veri kaydı (JSON formatında).|
|Column (Sütun)|**Field**|JSON içindeki alanlar (Ad, Soyad).|
|Schema|**Mapping**|Hangi alanın hangi tipte (Text, Keyword, Date) olduğu.|
|SELECT|**GET / Search API**|Veri çekme.|

**Dikkat:** Elasticsearch "Schema-less" (Şemasız) olarak bilinir, yani JSON'ı attığında kabul eder. Ancak **Mapping**'i (Şemayı) elle tanımlamak bir "Best Practice"tir. Aksi takdirde tarihi metin (string) olarak algılayabilir ve tarih bazlı arama yapamazsın.

---

### 4. ELK Stack (Ekosistem)

Elasticsearch genellikle tek başına kullanılmaz. Sektörde **ELK Stack** adı verilen muhteşem üçlü ile anılır:

1. **E - Elasticsearch:** Motor. Veriyi saklar ve arar.
    
2. **L - Logstash:** Boru hattı (Pipeline). Veriyi çeşitli kaynaklardan (Sunucu logları, SQL veritabanı, CSV dosyası) toplar, işler (parse eder) ve Elasticsearch'e atar.
    
3. **K - Kibana:** Arayüz (UI). Elasticsearch içindeki veriyi grafiklere, haritalara ve dashboard'lara döker.
    
    - _Kullanım:_ "Siteme son 1 saatte hangi ülkelerden saldırı geldi?" sorusunun cevabını Kibana haritasında izlersin.
        

_(Not: Artık "Beats" adında hafif veri toplayıcılar da eklendiği için bazen "Elastic Stack" denir)._

---

### 5. .NET Core Entegrasyonu (NEST)

C# ile Elasticsearch'e bağlanmak için resmi kütüphane **NEST** (veya yeni adıyla `Elastic.Clients.Elasticsearch`) kullanılır.

Elasticsearch **RESTful API** üzerinden (HTTP/JSON) haberleştiği için aslında `HttpClient` ile bile istek atabilirsin. Ancak NEST, bunu C# nesneleriyle (Typed) yapmanı sağlar.

C#

```cs
var settings = new ConnectionSettings(new Uri("http://localhost:9200"))
    .DefaultIndex("urunler"); // Varsayılan indeks

var client = new ElasticClient(settings);

// C# nesnesini indexle (Kaydet)
var urun = new Urun { Id = 1, Ad = "Kırmızı Mont" };
var response = await client.IndexDocumentAsync(urun);

// Arama Yap (LINQ benzeri sözdizimi)
var searchResponse = await client.SearchAsync<Urun>(s => s
    .Query(q => q
        .Match(m => m
            .Field(f => f.Ad)
            .Query("mont")
        )
    )
);
```

---

